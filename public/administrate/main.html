<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>하잇</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="/administrate/js/sidebar.js" defer></script>
    <script src="/administrate/js/profilebar.js" defer></script>
    <script src="/administrate/js/title.js" defer></script>
    <script src="/administrate/js/cardList.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <link rel="stylesheet" href="/administrate/css/sidebar.css">
    <link rel="stylesheet" href="/administrate/css/main.css">
    <link rel="stylesheet" href="/administrate/css/profilebar.css">
    <link rel="stylesheet" href="/administrate/css/title.css">
    <link rel="stylesheet" href="/administrate/css/font.css">
    <link rel="stylesheet" href="/administrate/css/cardList.css">
</head>

<style>

    #dashboardGraph{
        display: flex;
        flex-direction: column;
        background-color: white;
        min-width: 1400px;
        max-width: 1600px;
        box-shadow: 6px 6px 54px 0px rgba(0, 0, 0, 0.05);
        border-radius: 14px;
        margin: 40px 30px
        
    }

    #dashboardGraph .title-dashboard-graph{
        font-size: 24px;
        font-weight: 600;
        margin-left: 32px;
        margin-top: 37px;
    }

    #dashboardGraph .chart-container {
        width: 100%;
        height: 400px;
        overflow: hidden;
        cursor: grab;
        display: flex;
    }
    #dashboardGraph .chart-wrapper {
        width: 6000px;
        height: 400px;
        display: flex;
        align-items: center;
    }
    #dashboardGraph canvas {
        display: block;
    }

</style>

<body>
    <div id="main">
        <div id="sidebar"></div>
        <div class="content-container">
            <div id="profilebar"></div>
            <div id="title"></div>
            <div id="cardList"></div>
            
            <div id="dashboardGraph">
                <div class="title-dashboard-graph">식단 등록 횟수</div>
                <div class="chart-container">
                    <div class="chart-wrapper">
                        <canvas id="chartCanvas" width="6000" height="300"></canvas>
                    </div>
                </div>
            </div>
        </div>        
    </div>
</body>

<script>
    const canvas = document.getElementById("chartCanvas");
    const ctx = canvas.getContext("2d");

    let isDragging = false;
    let startX;
    let scrollOffset = 0;

    // 30일 데이터 생성
    function generateLast30Days() {
        let dates = [];
        let values = [];
        let today = new Date();
        for (let i = 29; i >= 0; i--) {
            let pastDate = new Date();
            pastDate.setDate(today.getDate() - i);
            let formattedDate = pastDate.toISOString().split('T')[0];
            dates.push(formattedDate);
            values.push(Math.floor(Math.random() * 100) + 1);
        }
        return { dates, values };
    }

    const { dates, values } = generateLast30Days();

    // 그래프 설정
    const chartWidth = 6000;
    const chartHeight = 300;
    const paddingTop = 50;    // 상단 padding
    const paddingRight = 50;  // 우측 padding
    const paddingBottom = 50; // 하단 padding
    const paddingLeft = 100;   // 좌측 padding
    const pointRadius = 5;
    const maxDataValue = Math.max(...values);
    const minDataValue = Math.min(...values);
    const scaleY = (chartHeight - paddingTop - paddingBottom) / (maxDataValue - minDataValue);

    function drawChart(offsetX = 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // X축 날짜 표시
        ctx.fillStyle = "#717171";
        ctx.font = "12px Pretendard";
        ctx.textAlign = "center";

        for (let i = 0; i < dates.length; i++) {
            let x = paddingLeft + i * (chartWidth - paddingLeft - paddingRight) / (dates.length - 1) + offsetX;

            // 첫 번째 날짜는 무조건 보이게 함
            if (i === 0 || (x > paddingLeft && x < chartWidth - paddingRight)) { 
                ctx.fillText(dates[i], x, chartHeight);
            }
        }

        // 그라데이션 생성
        let gradient = ctx.createLinearGradient(0, paddingTop, 0, chartHeight - paddingBottom);
        gradient.addColorStop(0, "rgba(235, 133, 133, 0.16)"); // 위쪽 (EB8585, 16%)
        gradient.addColorStop(1, "rgba(255, 255, 255, 0.18)"); // 아래쪽 (FFFFFF, 18%)

        // 데이터 영역 채우기
        ctx.beginPath();
        ctx.moveTo(paddingLeft + offsetX, chartHeight - paddingBottom);

        for (let i = 0; i < values.length; i++) {
            let x = paddingLeft + i * (chartWidth - paddingLeft - paddingRight) / (dates.length - 1) + offsetX;
            let y = chartHeight - paddingBottom - (values[i] - minDataValue) * scaleY;
            ctx.lineTo(x, y);
        }

        ctx.lineTo(chartWidth + offsetX - paddingRight, chartHeight - paddingBottom);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // 데이터 선 그리기
        ctx.beginPath();
        ctx.strokeStyle = "#EB8585";  // 선 색상
        ctx.lineWidth = 1;  // 선 두께 1px

        for (let i = 0; i < values.length; i++) {
            let x = paddingLeft + i * (chartWidth - paddingLeft - paddingRight) / (dates.length - 1) + offsetX;
            let y = chartHeight - paddingBottom - (values[i] - minDataValue) * scaleY;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();

        // 먼저 Y축 텍스트 영역 뒤에 흰색 배경을 그려주기
        ctx.fillStyle = "white";
        ctx.fillRect(0, 30, paddingLeft - 0, chartHeight - paddingBottom);
        // Y축 값 표시 및 구분선 그리기
        ctx.fillStyle = "#717171";
        ctx.font = "12px Pretendard";
        ctx.textAlign = "right";
        
        for (let i = 0; i <= 4; i++) {  // 5개의 값으로 변경
            let value = minDataValue + ((maxDataValue - minDataValue) / 4) * i;
            let y = chartHeight - paddingBottom - (value - minDataValue) * scaleY;
            ctx.fillText(Math.round(value), paddingLeft - 50, y + 5);

            // Y축에 얇은 구분선 추가
            ctx.beginPath();
            ctx.moveTo(paddingLeft - 5, y);
            ctx.lineTo(chartWidth + offsetX - paddingRight, y);
            ctx.strokeStyle = "lightgray";  // 얇은 구분선 색상
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }


    }
    
    scrollOffset = -(chartWidth - 1600);

    // 초기 차트 그리기
    drawChart(scrollOffset);

    // 드래그 이벤트 처리
    canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        startX = e.clientX - scrollOffset;
        canvas.style.cursor = "grabbing";
    });

    canvas.addEventListener("mouseup", () => {
        isDragging = false;
        canvas.style.cursor = "grab";
    });

    canvas.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        let newOffset = e.clientX - startX;
        scrollOffset = Math.max(Math.min(newOffset, 0), -chartWidth + 1500);
        drawChart(scrollOffset);
    });

</script>
</html>